{"/home/travis/build/npmtest/node-npmtest-marky-markdown/test.js":"/* istanbul instrument in package npmtest_marky_markdown */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/lib.npmtest_marky_markdown.js":"/* istanbul instrument in package npmtest_marky_markdown */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_marky_markdown = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_marky_markdown = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-marky-markdown && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_marky_markdown */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_marky_markdown\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_marky_markdown.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_marky_markdown.rollup.js'] =\n            local.assetsDict['/assets.npmtest_marky_markdown.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_marky_markdown.__dirname + '/lib.npmtest_marky_markdown.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/index.js":"var defaults = require('lodash.defaults')\nvar render = require('./lib/render')\nvar sanitize = require('./lib/sanitize')\n\nvar marky = module.exports = function (markdown, options) {\n  var html\n\n  if (typeof markdown !== 'string') {\n    throw Error('first argument must be a string')\n  }\n\n  options = options || {}\n  defaults(options, {\n    sanitize: true,\n    linkify: true,\n    highlightSyntax: true,\n    prefixHeadingIds: true,\n    enableHeadingLinkIcons: true,\n    serveImagesWithCDN: false,\n    debug: false,\n    package: null\n  })\n\n  var log = function (msg) {\n    if (options.debug) {\n      console.log('marky-markdown: ' + msg)\n    }\n  }\n\n  log('\\n\\n' + markdown + '\\n\\n')\n\n  log('Parse markdown into HTML and add syntax highlighting')\n  html = render(markdown, options)\n\n  if (options.sanitize) {\n    log('Sanitize malicious or malformed HTML')\n    html = sanitize(html, options)\n  }\n\n  return html\n}\n\nmarky.parsePackageDescription = function (description) {\n  return sanitize(render.renderPackageDescription(description))\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/render.js":"var pickBy = require('lodash.pickby')\nvar MD = require('markdown-it')\nvar lazyHeaders = require('markdown-it-lazy-headers')\nvar emoji = require('markdown-it-emoji')\nvar expandTabs = require('markdown-it-expand-tabs')\nvar githubTaskList = require('markdown-it-task-lists')\n\nvar cleanup = require('./cleanup')\nvar githubLinkify = require('./linkify')\n\nvar codeWrap = require('./plugin/code-wrap')\nvar headingLinks = require('./plugin/heading-links')\nvar gravatar = require('./plugin/gravatar')\nvar github = require('./plugin/github')\nvar youtube = require('./plugin/youtube')\nvar cdnImages = require('./plugin/cdn')\nvar badges = require('./plugin/badges')\nvar packagize = require('./plugin/packagize')\nvar relaxedLinkRefs = require('./gfm/relaxed-link-reference')\nvar githubHeadings = require('./gfm/indented-headings')\n\nif (typeof process.browser === 'undefined') {\n  var Highlights = require('highlights')\n  var highlighter = new Highlights()\n\n  var languages = [\n    'atom-language-nginx',\n    'atom-language-diff',\n    'language-dart',\n    'language-rust',\n    'language-erlang',\n    'language-glsl',\n    'language-haxe',\n    'language-ini',\n    'language-stylus'\n  ]\n\n  languages.forEach(function (language) {\n    highlighter.requireGrammarsSync({\n      modulePath: require.resolve(language + '/package.json')\n    })\n  })\n\n  // cleanup generated rules in the highlighter registry if they are idle for 2000ms\n  // they take a tremendous amount of memory if you process many languages in a server type environment.\n  cleanup(highlighter.registry.grammars)\n}\n\nvar render = module.exports = function (html, options) {\n  var mdOptions = {\n    html: true,\n    langPrefix: 'highlight ',\n    linkify: options.linkify\n  }\n\n  if (options.highlightSyntax) {\n    mdOptions.highlight = function (code, lang) {\n      return highlighter.highlightSync({\n        fileContents: code,\n        scopeName: scopeNameFromLang(highlighter, lang)\n      })\n    }\n  }\n\n  var parser = MD(mdOptions)\n    .use(lazyHeaders)\n    .use(emoji, {shortcuts: {}})\n    .use(expandTabs, {tabWidth: 4})\n    .use(githubTaskList)\n    .use(headingLinks, options)\n    .use(githubHeadings)\n    .use(relaxedLinkRefs)\n    .use(gravatar)\n    .use(github, {package: options.package})\n    .use(youtube)\n    .use(badges)\n    .use(packagize, {package: options.package})\n\n  if (options.highlightSyntax) parser.use(codeWrap)\n  if (options.serveImagesWithCDN) parser.use(cdnImages, {package: options.package})\n\n  return githubLinkify(parser).render(html)\n}\n\nvar mappings = {\n  sh: 'source.shell',\n  markdown: 'source.gfm',\n  erb: 'text.html.erb'\n}\n\n// attempt to look up by the long language name, e.g. Ruby, JavaScript.\n// fallback to assuming that lang is the extension of the code snippet.\nfunction scopeNameFromLang (highlighter, lang) {\n  // alias language names.\n\n  if (mappings[lang]) return mappings[lang]\n\n  var grammar = pickBy(highlighter.registry.grammarsByScopeName, function (val, key) {\n    return val.name.toLowerCase() === lang\n  })\n\n  if (Object.keys(grammar).length) {\n    return Object.keys(grammar)[0]\n  }\n\n  var name = 'source.' + lang\n  // mappings[lang] = name\n\n  return name\n}\n\nrender.renderPackageDescription = function (description) {\n  return MD({html: true}).renderInline(description)\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/cleanup.js":"var clean = require('property-ttl')\n\nmodule.exports = function (grammars) {\n  var managed = 0\n\n  var stops = []\n\n  scan()\n\n  return function stopAll () {\n    while (stops.length) stops.shift()()\n  }\n\n  function scan () {\n    while (managed < grammars.length - 1) {\n      stops.push(\n        clean(grammars[managed], 'repository', 2000, function () {\n          scan() // start watching new grammars if they are added later.\n        }),\n        clean(grammars[managed++], 'initialRule', 2000)\n      )\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/linkify.js":"// github-style linkification for linkify-it\n//\n// Pass in a markdown-it parser instance and this will return a version fixed\n// up for the kind of linkification we're after.\n//\n// As far as I can determine, the basic algorithm is to linkify anything\n// starting with 'www.' and ending with a) a whitespace character, or b) a dot\n// followed by a whitespace character (in other words, include internal dots,\n// but exclude a trailing dot). There are plenty of cases where this results in\n// invalid links, but that's how they do it, so that's how we'll do it.\n//\n\nfunction isInBrackets (text) {\n  return text.charAt(0) === '[' && text.charAt(text.length - 1) === ']'\n}\n\nfunction isInParens (text) {\n  return text.charAt(0) === '(' && text.charAt(text.length - 1) === ')'\n}\n\nmodule.exports = function (parser) {\n  if (parser) {\n    var linkify = parser.linkify\n\n    linkify.set({fuzzyLink: false}) // turn off auto-linking normal hostnames\n    linkify.add('//', null) // turn off protocol-relative links\n\n    // linkify everything hostnamey starting with 'www.', optionally in [] or ()\n    var scheme = {\n      validate: function (text, pos, self) {\n        if (!self.re.githubLinkify) {\n          self.re.githubLinkify = new RegExp('^' + self.re.src_host_port_strict + self.re.src_path, 'i')\n        }\n\n        // chop off any trailing ']' or ')', if necessary\n        var candidate = text.slice(pos)\n        if (isInBrackets(text) || isInParens(text)) {\n          candidate = candidate.slice(0, candidate.length - 1)\n        }\n\n        if (self.re.githubLinkify.test(candidate)) {\n          return candidate.match(self.re.githubLinkify)[0].length\n        } else if (candidate.charAt(0) === ' ') {\n          // if we have a zero-length match, i.e., if the original string was\n          // literally 'www.' all by itself, we return -1 because linkify-it does\n          // a boolean test on the result of the validator function (so we need a\n          // non-zero result here to make it through that test) and adds the\n          // returned value to an index it's using to point to the end of the\n          // matched substring. In this case, that means we'll move backwards one\n          // character and only link 'www' rather than the full 'www.' that was\n          // originally matched\n          return -1\n        }\n        return 0\n      },\n      normalize: function (match) {\n        // since we have 3 different \"schemes\" in place, our matched URLs might\n        // have a leading bracket or parenthesis; trim it off if necessary\n        if (match.schema.charAt(0) === 'w') {\n          match.url = 'http://' + match.url\n        } else {\n          match.url = 'http://' + match.url.slice(1)\n        }\n        match.schema = ''\n      }\n    }\n\n    parser.linkify.add('www.', scheme)\n    parser.linkify.add('[www.', scheme)\n    parser.linkify.add('(www.', scheme)\n\n    // linkify-it's default behavior is to create matches against the\n    // registered schema prefixes when the character immediately preceding a\n    // potential match is non-alphanumeric; however, we also need to skip\n    // linkification when said character is punctuation. So here we rebuild the\n    // internal regular expressions the LinkifyIt instance will use.\n    var regexes = linkify.re\n    regexes.schema_test = RegExp(regexes.schema_test.source.replace(regexes.src_ZPCc, regexes.src_ZCc), 'i')\n    regexes.schema_search = RegExp(regexes.schema_search.source.replace(regexes.src_ZPCc, regexes.src_ZCc), 'ig')\n    regexes.pretest = RegExp('(' + regexes.schema_test.source + ')|(' + regexes.host_fuzzy_test.source + ')|@', 'i')\n  }\n\n  return parser\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/plugin/code-wrap.js":"var plugin = module.exports = function (md, options) {\n  // monkey patch the 'fence' parsing rule to restore markdown-it's pre-5.1 behavior\n  // (see https://github.com/markdown-it/markdown-it/issues/190)\n  var stockFenceRule = md.renderer.rules.fence\n  md.renderer.rules.fence = function (tokens, idx, options, env, slf) {\n    // call the original rule first rather than inside the 'return' statement\n    // because we need the 'class' attribute processing it does\n    var output = stockFenceRule(tokens, idx, options, env, slf).trim()\n\n    // markdown-it 6.1 and later stopped overwriting the class attribute in the\n    // renderer rule, so we construct it ourselves here\n    var token = tokens[idx]\n    var index = token.attrIndex('class')\n    var attributes = token.attrs ? token.attrs.slice() : []\n    var langName = token.info.split(/\\s+/g)[0]\n    var classes = options.langPrefix + langName\n\n    if (index < 0) {\n      attributes.push(['class', classes])\n    } else {\n      attributes[index] += ' ' + classes\n    }\n\n    var fakeToken = {\n      attrs: attributes\n    }\n\n    return '<' + plugin.tag + slf.renderAttrs(fakeToken) + '>' + output + '</' + plugin.tag + '>\\n'\n  }\n}\n\nplugin.tag = 'div'\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/plugin/heading-links.js":"var GithubSlugger = require('github-slugger')\nvar innertext = require('innertext')\nvar tokenUtil = require('../token-util')\n\n// shamelessly borrowed from GitHub, thanks y'all\nvar svgLinkIconText = '<svg aria-hidden=\"true\" class=\"deep-link-icon\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg>'\n\nvar headings = module.exports = function (md, options) {\n  if (options && !options.prefixHeadingIds) {\n    headings.prefix = ''\n  } else {\n    headings.prefix = headings.prefix || headings.defaultPrefix\n  }\n\n  var slugger = new GithubSlugger()\n  var Token\n\n  md.core.ruler.push('headingLinks', function (state) {\n    // save the Token constructor because we'll be building a few instances at render\n    // time; that's sort of outside the intended markdown-it parsing sequence, but\n    // since we have tight control over what we're creating (a link), we're safe\n    if (!Token) {\n      Token = state.Token\n      tokenUtil.set(Token)\n    }\n  })\n\n  md.renderer.rules.heading_open = function (tokens, idx, opts, env, self) {\n    var children = tokens[idx + 1].children\n    // make sure heading is not empty\n    if (children && children.length) {\n      // Generate an ID based on the heading's innerHTML; first, render without\n      // converting gemoji strings to unicode emoji characters\n      var rendered = md.renderer.renderInline(children.map(tokenUtil.unemoji), opts, env)\n      var postfix = slugger.slug(\n        innertext(rendered)\n          .replace(/[<>]/g, '') // In case the heading contains `<stuff>`\n          .toLowerCase() // because `slug` doesn't lowercase\n      )\n\n      // add 3 new token objects link_open, text, link_close\n      var linkOpen = new Token('link_open', 'a', 1)\n      var text = new Token('html_inline', '', 0)\n      if (options && options.enableHeadingLinkIcons) {\n        text.content = svgLinkIconText\n      }\n      var linkClose = new Token('link_close', 'a', -1)\n\n      // add some link attributes\n      linkOpen.attrSet('id', headings.prefix + postfix)\n      linkOpen.attrSet('class', headings.className)\n      linkOpen.attrSet('href', '#' + postfix)\n\n      // add new token objects as children of heading\n      children.unshift(linkClose)\n      children.unshift(text)\n      children.unshift(linkOpen)\n    }\n\n    return md.renderer.renderToken(tokens, idx, options, env, self)\n  }\n}\n\nheadings.defaultPrefix = 'user-content-'\nheadings.className = 'deep-link'\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/token-util.js":"var assign = require('lodash.assign')\n\nvar Token // Token constructor from markdown-it\n\nvar tokenUtil = module.exports = {}\n\ntokenUtil.set = function (TokenConstructor) {\n  Token = TokenConstructor\n}\n\n// Look for tokens with type === 'emoji', which are :shortcode: style emoji\n// characters that have been replaced by the markdown-it-emoji plugin. Return the\n// original tokens, unless they were converted gemoji strings; then return a copy so\n// we haven't clobbered the original when it comes time to render HTML\ntokenUtil.unemoji = function (token) {\n  if (token.type === 'emoji') {\n    return assign(new Token(), token, {content: token.markup})\n  }\n  return token\n}\n\n// return true if the token is type 'text' or contains any such tokens (except\n// for images; they can contain 'text' children because that's how `alt`\n// attributes get represented; those don't count toward the text representation)\ntokenUtil.isText = function isText (token) {\n  var containsTextTokens = false\n  if (token.children && token.children.length) {\n    containsTextTokens = token.type !== 'image' && token.children.some(isText)\n  }\n  return containsTextTokens || token.type === 'text'\n}\n\n// extract the text from the given 'inline' token\ntokenUtil.getText = function getText (token) {\n  var text = token.type === 'text' ? token.content : ''\n  if (token.children && token.children.length) {\n    text += token.children.reduce(function (previous, current) {\n      return previous + (token.type !== 'image' ? getText(current) : '')\n    }, '')\n  }\n  return text\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/plugin/gravatar.js":"// markdown-it plugin that ensures all gravatar img src URLs are secure\n//\nvar URL = require('url')\n\nmodule.exports = function (md, opts) {\n  // patch the current rule, don't replace it completely\n  var originalRule = md.renderer.rules.image\n  md.renderer.rules.image = function (tokens, idx, options, env, self) {\n    var url = URL.parse(tokens[idx].attrGet('src'))\n    if (url.host && url.host.match(/^(\\w+\\.)?gravatar\\.com$/)) {\n      url.protocol = 'https'\n      url.host = 'secure.gravatar.com'\n      tokens[idx].attrSet('src', URL.format(url))\n    }\n    return originalRule.call(this, tokens, idx, options, env, self)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/plugin/github.js":"// markdown-it plugin to rewrite image and link URLs to be static github URLs\n// when the calling code provides github repository information\n//\nvar gh = require('github-url-to-object')\nvar URL = require('url')\nvar path = require('path')\n\nmodule.exports = function (md, opts) {\n  if (!opts) return\n  if (!opts.package) return\n  if (!opts.package.repository) return\n\n  var repo = gh(opts.package.repository.url)\n\n  if (!repo) return\n\n  // rewrite image locations to be fully qualified github URLs\n  var originalImageRule = md.renderer.rules.image\n  md.renderer.rules.image = function (tokens, idx, options, env, self) {\n    var src = tokens[idx].attrGet('src')\n\n    if (src && src.length) {\n      var url = URL.parse(src)\n\n      // Skip fully-qualified URLs, #hash fragments, and protocol-relative URLs\n      if (!url.host && url.path && !url.path.match(/^\\/\\//)) {\n        tokens[idx].attrSet('src', 'https://raw.githubusercontent.com/' + path.join(\n            repo.user,\n            repo.repo,\n            'master',\n            url.href)\n        )\n      }\n    }\n    return originalImageRule.call(this, tokens, idx, options, env, self)\n  }\n\n  // rewrite link hrefs to be fully qualified github URLs\n  var originalLinkRule = md.renderer.rules.link_open\n  md.renderer.rules.link_open = function (tokens, idx, options, env, self) {\n    var href = tokens[idx].attrGet('href')\n\n    if (href && href.length) {\n      var url = URL.parse(href)\n\n      // Skip fully-qualified URLs, #hash fragments, and protocol-relative URLs\n      if (!url.host && url.path && !url.path.match(/^\\/\\//)) {\n        tokens[idx].attrSet('href', repo.https_url + path.join('/blob/master/', url.href))\n      }\n    }\n    if (originalLinkRule) {\n      return originalLinkRule.call(this, tokens, idx, options, env, self)\n    } else {\n      return md.renderer.renderToken(tokens, idx, options)\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/plugin/youtube.js":"// markdown-it plugin to wrap youtube iframes in a <div> for styling purposes\n//\nvar URL = require('url')\n\nvar WRAPPER_START = \"<div class='youtube-video'>\"\nvar WRAPPER_END = '</div>'\n\n// determine whether the given HTML string contains an iframe pointing to a youtube.com URL\nfunction isYoutubeIframe (content) {\n  // look for the src attribute's value\n  var attr = content.match(/<\\s*iframe[^>]*\\bsrc\\s*=\\s*/)\n  if (attr) {\n    // mark the location and figure out what kind of quotation mark is delimiting the value\n    var position = attr.index + attr[0].length\n    var quote = content.charAt(position)\n    var substring = content.slice(position + 1)\n\n    // now that we've found the first delimiting quotation mark, match\n    // everything up to the next instance of the same quotation mark\n    var src = substring.match(new RegExp('^[^' + quote + ']*'))\n    if (src) {\n      var value = src[0]\n      // for protocol-relative src, prepend a protocol for URL parsing purposes\n      if (value.indexOf('//') === 0) {\n        value = 'https:' + value\n      }\n\n      var url = URL.parse(value)\n      return (url.host && url.host.match(/^(\\w+\\.)?youtube\\.com$/))\n    }\n  }\n  return false\n}\n\nmodule.exports = function (md, opts) {\n  // Wrap iframes that appear in HTML blocks\n  //\n  // In html_block tokens, the entire contents of an HTML block appear as the\n  // `.content` property of a single token object. For a standalone `<iframe>`,\n  // wrapping it with our `<div>` is pretty straightforward, but when it\n  // appears deeper inside the snippet, we have to do a little more parsing\n  // work to figure out where to insert our wrapping elements.\n  //\n  var originalBlockRule = md.renderer.rules.html_block\n  md.renderer.rules.html_block = function (tokens, idx, options, env, self) {\n    var content = tokens[idx].content\n\n    if (isYoutubeIframe(content)) {\n      // start by assuming the entire block is solely made up of the iframe\n      var start = 0\n      var end = content.length\n\n      // check to see where the iframe actually starts\n      var isDeep = content.match(/>\\s*<\\s*iframe/)\n      if (isDeep) {\n        start = content.substring(isDeep.index).indexOf('<') + isDeep.index\n      }\n\n      // find the closing `</iframe>` tag, so we can find the end of it\n      var closingMatch = content.substring(start).match(/>[^>]*<\\s*\\/\\s*iframe\\s*>/)\n      if (closingMatch) {\n        var endOffset = content.substring(start + closingMatch.index + 1).indexOf('>') + 1\n        end = start + closingMatch.index + endOffset + 1\n      }\n\n      // slice up the content according to the positions we've computed\n      var prefix = content.substring(0, start)\n      var iframe = content.substring(start, end)\n      var postfix = content.substring(end)\n\n      // inject the wrapper element\n      tokens[idx].content = prefix + WRAPPER_START + iframe + WRAPPER_END + postfix\n    }\n\n    return originalBlockRule.call(this, tokens, idx, options, env, self)\n  }\n\n  // Wrap iframes that appear inside inline HTML strings\n  //\n  // In runs of html_inline tokens, the opening `<iframe>` tag will appear in a\n  // separate token from the closing `</iframe>` tag, so what we have to do if we\n  // find a match is walk through the list to find out where to put the closing\n  // `</div>` part of our wrapper\n  //\n  var originalInlineRule = md.renderer.rules.html_inline\n  md.renderer.rules.html_inline = function (tokens, idx, options, env, self) {\n    if (isYoutubeIframe(tokens[idx].content)) {\n      // prepend the opening part of the wrapper\n      tokens[idx].content = WRAPPER_START + tokens[idx].content\n\n      // find the closing tag and append the closing part of the wrapper\n      for (var position = idx; position < tokens.length && tokens[position].type === 'html_inline'; position++) {\n        if (tokens[position].content === '</iframe>') {\n          tokens[position].content += WRAPPER_END\n        }\n      }\n    }\n\n    return originalInlineRule.call(this, tokens, idx, options, env, self)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/plugin/cdn.js":"// This plugin rewrites relative image URLs to use cdn.npm.im instead, when the\n// calling code provides package.json data (at least name and version)\n//\nvar URL = require('url')\nvar path = require('path')\n\n// CDN-ize image URLs\n\nmodule.exports = function (md, opts) {\n  if (!opts) return\n  if (!opts.package) return\n  if (!opts.package.name) return\n  if (!opts.package.version) return\n\n  var originalRule = md.renderer.rules.image\n  md.renderer.rules.image = function (tokens, idx, options, env, self) {\n    var url = URL.parse(tokens[idx].attrGet('src'))\n\n    // skip fully-qualified and protocol-relative URLs\n    if (!url.host && !url.path.match(/^\\/\\//)) {\n      url.protocol = 'https'\n      url.host = 'cdn.npm.im'\n      url.pathname = '/' + opts.package.name + '@' + opts.package.version + path.join('/', url.path)\n      tokens[idx].attrSet('src', URL.format(url))\n    }\n\n    return originalRule.call(this, tokens, idx, options, env, self)\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/plugin/badges.js":"// This plugin marks badges in rendered docuemnts. The markdown processor wraps\n// paragraph tags around standalone elements like badge images. For example:\n//\n//     [![maude](http://cats.com/maude.jpg)](http://cats.com)\n//\n// renders as\n//\n//     <p>\n//       <a href=\"http://cats.com\">\n//         <img src=\"http://cats.com/maude.jpg\" alt=\"maude\">\n//       </a>\n//     </p>\n//\n// so what we do is check to see if the URL provided is a badge, and if it is,\n// mark the image with `class='badge'`. If the surrounding paragraph contains no\n// text, the paragraph gets marked with `class='badge-only'`.\n//\nvar isBadge = require('is-badge')\nvar tokenUtil = require('../token-util')\n\nfunction isImage (token) {\n  return token.type === 'image'\n}\n\nfunction getUrl (token) {\n  return token.attrGet('src')\n}\n\nmodule.exports = function (md, opts) {\n  //\n  // Add class='badge' to badge images\n  //\n  var originalRule = md.renderer.rules.image\n  md.renderer.rules.image = function (tokens, idx, options, env, self) {\n    var src = tokens[idx].attrGet('src')\n\n    if (src && src.length && isBadge(src)) {\n      tokens[idx].attrJoin('class', 'badge')\n    }\n    return originalRule.call(this, tokens, idx, options, env, self)\n  }\n\n  //\n  // Add class='badge-only' to paragraphs containing badges and no text\n  //\n  var originalParagraphRule = md.renderer.rules.paragraph_open\n  md.renderer.rules.paragraph_open = function (tokens, idx, options, env, self) {\n    var paragraph = tokens[idx]\n    var contents = tokens[idx + 1]\n    var hasContents = !!contents.children\n\n    if (!paragraph.hidden && hasContents && !contents.children.some(tokenUtil.isText)) {\n      // if the only child tokens are badge images, add the class\n      if (contents.children.filter(isImage).map(getUrl).every(isBadge)) {\n        tokens[idx].attrJoin('class', 'badge-only')\n      }\n    }\n\n    if (originalParagraphRule) {\n      return originalParagraphRule.call(this, tokens, idx, options, env, self)\n    } else {\n      return md.renderer.renderToken(tokens, idx, options)\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/plugin/packagize.js":"// markdown-it plugin to add some helper classes to existing elements that look\n// like duplicates of package names and descriptions\n//\nvar similarity = require('similarity')\nvar tokenUtil = require('../token-util')\n\nmodule.exports = function (md, opts) {\n  if (!opts) return\n  if (!opts.package) return\n  if (!opts.package.name) return\n\n  var packageName = opts.package.name\n  var packageDescription = opts.package.description + '' // invalid description in some cases can cause a crash\n\n  //\n  // process the first <h1> element\n  //\n  var originalHeadingRule = md.renderer.rules.heading_open\n  md.renderer.rules.heading_open = function (tokens, idx, options, env, self) {\n    if (tokens[idx].tag === 'h1' && !env.packagizeHeadingDone) {\n      // extract the text from the heading's 'inline' token\n      var text = tokenUtil.getText(tokens[idx + 1])\n\n      // check to see if the heading text matches the package name\n      if (\n        similarity(packageName, text) > 0.6 ||\n        similarity(packageName.replace(/^@[^/]+\\//, ''), text) > 0.6 || // filter out scope name\n        ~text.toLowerCase().indexOf(packageName.toLowerCase())\n      ) {\n        tokens[idx].attrJoin('class', 'package-name-redundant')\n      }\n\n      // check to see if the heading text matches the package description\n      if (packageDescription && (\n        similarity(packageDescription, text) > 0.6 ||\n        ~text.toLowerCase().indexOf(packageDescription.toLowerCase())\n        )) {\n        tokens[idx].attrJoin('class', 'package-description-redundant')\n      }\n\n      // only inspect the first h1; skip the rest\n      env.packagizeHeadingDone = true\n    }\n    return originalHeadingRule.call(this, tokens, idx, options, env, self)\n  }\n\n  //\n  // process the first paragraph that contains text\n  //\n  var originalParagraphRule = md.renderer.rules.paragraph_open\n  md.renderer.rules.paragraph_open = function (tokens, idx, options, env, self) {\n    if (!env.packagizeParagraphDone) {\n      // extract the text from the paragraph's 'inline' token\n      var text = tokenUtil.getText(tokens[idx + 1])\n\n      // check to see if the paragraph text matches the description\n      if (similarity(packageDescription, text) > 0.6) {\n        tokens[idx].attrJoin('class', 'package-description-redundant')\n      }\n\n      // inspect the first paragraph that contains text; skip the rest\n      if (text) {\n        env.packagizeParagraphDone = true\n      }\n    }\n    if (originalParagraphRule) {\n      return originalParagraphRule.call(this, tokens, idx, options, env, self)\n    } else {\n      return md.renderer.renderToken(tokens, idx, options)\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/gfm/relaxed-link-reference.js":"module.exports = function (md, options) {\n  // Unfortunately, there's no public API for getting access to the existing\n  // installed parsing rules; rather than import the 'reference' rule directly\n  // from markdown-it just so we can re-install it into the parser with the\n  // 'alt' chain set up correctly, here we're just using internal utility\n  // methods to modify it in place at runtime.\n  //\n  // The net result is that we allow what are known in the CommonMark spec as\n  // \"link reference definitions\" to interrupt paragraphs, i.e., we relax the\n  // requirement that there be a blank line between a paragraph and a reference\n  // definition.\n  //\n  // That means that this works:\n  //\n  //   Some paragraph text here with a [linkref]\n  //   [linkref]: /actual/link/destination/here\n  //\n  // ...whereas spec compliance requires a blank line between the two.\n\n  var ruler = md.block.ruler\n  var idx = ruler.__find__('reference')\n  ruler.__rules__[idx].alt.push('paragraph')\n  ruler.__compile__()\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/gfm/indented-headings.js":"module.exports = function (md, options) {\n  // Unfortunately, there's no public API for getting access to the existing\n  // installed parsing rules; rather than import the 'heading' rule directly\n  // from markdown-it just so we can wrap it with our own processing, we have to\n  // use internal utility methods to pick it up first, then do the replacement\n  // via normal means.\n  //\n  // This plugin allows us to more closely mimic GitHub's heading parsing. Per\n  // CommonMark, ATX headings are allowed to have one to three spaces before the\n  // hash characters. GitHub doesn't allow any leading whitespace whatsoever.\n  //\n  // For example (the `·` characters represent spaces):\n  //\n  // ·### Renders as H3 in CommonMark\n  // ··## Renders as H2 in CommonMark\n  // ···# Renders as H1 in CommonMark\n  //\n  // ... whereas on GitHub, those become standard paragraphs.\n\n  var ruler = md.block.ruler\n  var originalRule = ruler.__rules__[ruler.__find__('heading')].fn\n\n  ruler.at('heading', function (state, startLine, endLine, silent) {\n    // conveniently, state.tShift holds a count of the number of leading spaces\n    // on each line, so all we need to do is return false if it's non-zero\n    if (state.tShift[startLine] > 0) {\n      return false\n    } else {\n      return originalRule.apply(this, arguments)\n    }\n  })\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/sanitize.js":"var sanitizeHtml = require('sanitize-html')\nvar sanitizer = module.exports = function (html, options) {\n  var config\n  if (options && options.prefixHeadingIds) {\n    config = Object.assign({}, sanitizer.config, {\n      transformTags: {\n        '*': prefixHTMLids,\n        'td': sanitizeCellStyle,\n        'th': sanitizeCellStyle\n      }\n    })\n  } else {\n    config = sanitizer.config\n  }\n  return sanitizeHtml(html, config)\n}\n\nsanitizer.config = {\n  allowedTags: sanitizeHtml.defaults.allowedTags.concat([\n    'dd', 'del', 'div', 'dl', 'dt', 'h1', 'h2', 'iframe', 'img', 'input', 'ins', 'meta', 'path', 'pre', 's', 'span', 'sub', 'sup', 'svg'\n  ]),\n  allowedClasses: {\n    a: ['deep-link'],\n    div: [\n      'highlight',\n      'hljs',\n      'bash',\n      'css',\n      'coffee',\n      'coffeescript',\n      'diff',\n      'glsl',\n      'http',\n      'js',\n      'javascript',\n      'json',\n      'lang-html',\n      'line',\n      'sh',\n      'shell',\n      'typescript',\n      'xml',\n      'youtube-video'\n    ],\n    h1: ['deep-link', 'package-name-redundant', 'package-description-redundant'],\n    h2: ['deep-link'],\n    h3: ['deep-link'],\n    h4: ['deep-link'],\n    h5: ['deep-link'],\n    h6: ['deep-link'],\n    img: ['badge'],\n    input: ['task-list-item-checkbox'],\n    li: ['task-list-item'],\n    ol: ['task-list'],\n    p: ['badge-only', 'package-description-redundant'],\n    pre: ['editor', 'editor-colors'],\n    span: require('./highlights-tokens'),\n    svg: ['deep-link-icon'],\n    ul: ['task-list']\n  },\n  allowedAttributes: {\n    h1: ['id'],\n    h2: ['id'],\n    h3: ['id'],\n    h4: ['id'],\n    h5: ['id'],\n    h6: ['id'],\n    a: ['href', 'id', 'name', 'target', 'title'],\n    img: ['alt', 'id', 'src', 'width', 'height', 'align', 'valign', 'title'],\n    p: ['align'],\n    meta: ['name', 'content'],\n    iframe: ['src', 'frameborder', 'allowfullscreen'],\n    input: ['checked', 'class', 'disabled', 'type'],\n    div: ['id'],\n    span: [],\n    pre: [],\n    td: ['colspan', 'rowspan', 'style'],\n    th: ['colspan', 'rowspan', 'style'],\n    del: ['cite', 'datetime'],\n    ins: ['cite', 'datetime'],\n    path: ['d'],\n    svg: ['aria-hidden', 'height', 'version', 'viewBox', 'width']\n  },\n  exclusiveFilter: function (frame) {\n    // Allow Task List items\n    if (frame.tag === 'input') {\n      var isTaskItem = (frame.attribs.class && frame.attribs.class.indexOf('task-list-item-checkbox') > -1)\n      var isCheckbox = (frame.attribs.type && frame.attribs.type === 'checkbox')\n      var isDisabled = frame.attribs.hasOwnProperty('disabled')\n      return !(isTaskItem && isCheckbox && isDisabled)\n    }\n\n    // Allow YouTube iframes\n    if (frame.tag !== 'iframe') return false\n    return !String(frame.attribs.src).match(/^(https?:)?\\/\\/(www\\.)?youtube\\.com/)\n  },\n  transformTags: {\n    'td': sanitizeCellStyle,\n    'th': sanitizeCellStyle\n  }\n}\n\n// Allow table cell alignment\nfunction sanitizeCellStyle (tagName, attribs) {\n  // if we don't add the 'style' to the allowedAttributes above, it will be\n  // stripped out by the time we get here, so we have to filter out\n  // everything but `text-align` in case something else tries to sneak in\n  function cell (alignment) {\n    var attributes = attribs\n    if (alignment) {\n      attributes.style = 'text-align:' + alignment\n    } else {\n      delete attributes.style\n    }\n    return {\n      tagName: tagName,\n      attribs: attributes\n    }\n  }\n\n  // look for CSS `text-align` directives\n  var alignmentRegEx = /text-align\\s*:\\s*(left|center|right)[\\s;$]*/igm\n  var result = alignmentRegEx.exec(attribs.style || '')\n  return result ? cell(result[1]) : cell()\n}\n\nfunction prefixHTMLids (tagName, attribs) {\n  if (attribs.id && !isAlreadyPrefixed(attribs.id, 'user-content-')) {\n    attribs.id = 'user-content-' + attribs.id\n  }\n  return {tagName, attribs}\n}\n\nfunction isAlreadyPrefixed (id, prefix) {\n  return id.includes(prefix) && id.length > prefix.length\n}\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/lib/highlights-tokens.js":"var stockHighlightsTokens = require('highlights-tokens')\nvar diffTokens = require('atom-language-diff')\n\n// combine stock highlights tokens list with any additional ones we've included\n\nmodule.exports = [].concat(stockHighlightsTokens, diffTokens)\n","/home/travis/build/npmtest/node-npmtest-marky-markdown/node_modules/marky-markdown/bin/marky-markdown.js":"#!/usr/bin/env node\nvar fs = require('fs')\nvar path = require('path')\nvar marky = require('..')\n\nif (process.argv.length < 3) {\n  console.log('Usage:\\n\\nmarky-markdown some.md > some.html')\n  process.exit()\n}\n\nvar filePath = path.resolve(process.cwd(), process.argv[2])\n\nfs.readFile(filePath, function (err, data) {\n  if (err) throw err\n  var html = marky(data.toString())\n  process.stdout.write(html)\n})\n"}